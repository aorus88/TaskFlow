import React, { useState, useEffect, useContext, useRef } from "react";
import "./FusionTool.css"; // Importer les styles sp√©cifiques
import { Bar } from "react-chartjs-2"; // Importer le composant Bar de react-chartjs-2
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
} from "chart.js"; // Importer les composants n√©cessaires de Chart.js
import ChartDataLabels from "chartjs-plugin-datalabels"; // Importer le plugin pour afficher les valeurs sur le graphique
import { SelectedTaskContext } from "../context/SelectedTaskContext"; // Importer le contexte
import TaskForm from "../components/TaskForm"; // Importer le composant TaskForm
import ConsumptionFilters from "../components/ConsumptionFilters"; // Importer le composant ConsumptionFilters
import { format } from "date-fns";

// Enregistrer les composants n√©cessaires de Chart.js, y compris le plugin datalabels
ChartJS.register(CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend, ChartDataLabels);

const StatCard = ({ label, value, emoji, color }) => {
  return (
    <div
      className="stat-card"
      style={{ borderColor: color, backgroundColor: `${color}33` }}
    >
      <h3 className="stat-card-label">{label}</h3>
      <p className="stat-card-value" style={{ color: color }}>
        {value} {emoji}
      </p>
    </div>
  );
};

const BarChartCard = ({ label, data, color = "#4285f4" }) => {
  // -------------------------------
  // 1. √âTATS
  // -------------------------------
  const [isExpanded, setIsExpanded] = useState(false);
  
  // -------------------------------
  // 2. FONCTIONS AUXILIAIRES
  // -------------------------------
  const toggleExpand = () => {
    setIsExpanded(!isExpanded);
  };
  
  // Fonction pour formater les dates
  const formatChartDate = (dateStr) => {
    if (!dateStr) return "";
    
    try {
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        // R√©cup√©rer l'initiale du jour de la semaine
        const weekday = date.toLocaleDateString("fr-FR", {
          weekday: "narrow" // "narrow" donne g√©n√©ralement l'initiale (L, M, M...)
        });
        
        // Formater la date comme avant
        const dayMonth = date.toLocaleDateString("fr-FR", {
          day: "numeric",
          month: "short",
        });
        
        // Combiner les deux
        return `${weekday} ${dayMonth}`;
      }
      return dateStr;
    } catch (error) {
      console.error("Erreur format date:", dateStr);
      return dateStr;
    }
  };

  // -------------------------------
  // 3. DONN√âES DU GRAPHIQUE
  // -------------------------------
  const chartData = {
    labels: data.map((entry) => entry.date),
    datasets: [
      {
        label: "üçÇ",
        data: data.map((entry) => entry.count),
        backgroundColor: data.map((entry) => {
          if (entry.count < 3) {
            return "rgba(0, 255, 0, 0.2)"; // Vert pour < 3
          } else if (entry.count >= 3 && entry.count <= 6) {
            return "rgba(255, 165, 0, 0.2)"; // Orange pour 3 √† 6
          } else {
            return "rgba(255, 0, 0, 0.2)"; // Rouge pour > 6
          }
        }),
        borderColor: data.map((entry) => {
          if (entry.count < 3) {
            return "rgba(0, 255, 0, 0.2)"; // Vert pour < 3
          } else if (entry.count >= 3 && entry.count <= 6) {
            return "rgba(255, 165, 0, 0.2)"; // Orange pour 3 √† 6
          } else {
            return "rgba(255, 0, 0, 0.2)"; // Rouge pour > 6
          }
        }),
        borderWidth: 1,
      },
      {
        label: "üèÜ",
        data: data.map((entry) => entry.noCount),
        backgroundColor: data.map((entry) => {
          if (entry.noCount < 3) {
            return "rgba(144, 238, 144, 0.2)"; // Vert clair pour < 3
          } else if (entry.noCount >= 3 && entry.noCount <= 6) {
            return "rgba(60, 179, 113, 0.2)"; // Vert moyen pour 3 √† 6
          } else {
            return "rgba(0, 128, 0, 0.2)"; // Vert fonc√© pour > 6
          }
        }),
        borderColor: data.map((entry) => {
          if (entry.noCount < 3) {
            return "rgba(144, 238, 144, 1)"; // Vert clair pour < 3
          } else if (entry.noCount >= 3 && entry.noCount <= 6) {
            return "rgba(60, 179, 113, 1)"; // Vert moyen pour 3 √† 6
          } else {
            return "rgba(0, 128, 0, 1)"; // Vert fonc√© pour > 6
          }
        }),
        borderWidth: 1,
      },
    ],
  };

  // -------------------------------
  // 4. OPTIONS DU GRAPHIQUE
  // -------------------------------
  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: "top",
        align: "center",
        labels: { 
          font: { size: 18 }, 
          color: "#333",
          padding: 2, // Augmentez cette valeur (25 ‚Üí 40 ou plus)
        },
        // Ajoutez une marge suppl√©mentaire
        margin: {
          top: 0, // Marge sup√©rieure additionnelle
          bottom: 10
        },
        title: {
          display: false,
          padding: {
            top: 20, // Augmentez cette valeur (102‚Üí 20)
            bottom: 10
          }
        }
      },
      tooltip: {
        callbacks: {
          label: function (context) {
            let label = context.dataset.label || "";
            if (label) label += ": ";
            if (context.parsed.y !== null) label += context.parsed.y;
            return label;
          },
        },
      },
      datalabels: {
        display: true,
        color: "#000",
        anchor: "end",
        align: "end",
        offset: 4,
        font: {
          weight: 'bold',
          size: 12,
        },
        backgroundColor: 'rgba(255, 255, 255, 0.94)',
        borderRadius: 4,
        padding: {
          top: 2,
          bottom: 2,
          left: 4,
          right: 4,
        },
        formatter: (value) => value,
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        title: { display: true, text: "/ jour", color: "#333", font: { size: 18 } },
        ticks: { color: "#333", font: { size: 12 } },
        grid: { color: "rgba(0, 0, 0, 0)" },
      },
      x: {
        title: { display: true, color: "#333", font: { size: 18 } },
        ticks: {
          color: "#333",
          font: { size: 12 },
          callback: function (value, index) {
            // R√©cup√©rer directement la date √† partir des labels originaux
            return formatChartDate(chartData.labels[index]);
          },
        },
        grid: { color: "rgba(0, 0, 0, 0)" },
      },
    },
    animation: { duration: 1200, easing: "easeOutQuart" },
  };

  // -------------------------------
  // 5. RENDU JSX
  // -------------------------------
  return (
    <div
      className="stat-card"
      style={{ borderColor: color, backgroundColor: `${color}33` }}
    >
      <div className="chart-header">
        <h3 className="stat-card-label">{label}</h3>
        <button 
          onClick={toggleExpand} 
          className="toggle-chart-btn"
        >
          {isExpanded ? 'R√©duire ‚Üë' : 'D√©velopper ‚Üì'}
        </button>
      </div>
      
      {isExpanded && (
        <div style={{ height: "300px", width: "100%" }}>
          <Bar 
            data={chartData} 
            options={options} 
            key={`chart-${isExpanded}`} 
          />
        </div>
      )}
      
      
      {!isExpanded && (
  <div className="chart-preview" style={{ padding: "10px 0", textAlign: "center" }}>
    <p>Cliquez sur "D√©velopper" pour voir le graphique</p>
    <div className="mini-chart">
      {data.slice(-15).map((entry, index) => (
        <div key={`${index}-container`} className="mini-bar-container" style={{ display: 'inline-block', margin: '0 2px' }}>
          {/* Barre pour les entr√©es "yes" (üçÇ) */}
          <div 
            key={`yes-${index}`} 
            className="mini-bar" 
            style={{
              height: `${Math.min(entry.count * 5, 30)}px`,
              width: '6px',
              display: 'inline-block',
              backgroundColor: entry.count < 3 
                ? "rgba(0, 255, 0, 0.5)" 
                : entry.count <= 6 
                  ? "rgba(255, 165, 0, 0.5)" 
                  : "rgba(255, 0, 0, 0.5)",
              marginRight: '2px'
            }}
            title={`üçÇ ${entry.date}: ${entry.count}`}
          ></div>
          
          {/* Barre pour les entr√©es "no" (üèÜ) */}
          <div 
            key={`no-${index}`} 
            className="mini-bar" 
            style={{
              height: `${Math.min(entry.noCount * 5, 30)}px`,
              width: '6px',
              display: 'inline-block',
              backgroundColor: entry.noCount < 3 
                ? "rgba(144, 238, 144, 0.5)" 
                : entry.noCount <= 6 
                  ? "rgba(60, 179, 113, 0.5)" 
                  : "rgba(0, 128, 0, 0.5)"
            }}
            title={`üèÜ ${entry.date}: ${entry.noCount}`}
          ></div>
        </div>
      ))}
    </div>
  </div>
)}



    </div>
  );
};

const FusionTool = ({
  entries,
  onAddEntry,
  onDeleteEntry,
  isDarkMode,
  toggleDarkMode,
  onAddTask,
  taskCategories,
}) => {
  // Gestion des t√¢ches et du contexte
  const [tasks, setTasks] = useState([]);
  const [isTaskFormModalOpen, setIsTaskFormModalOpen] = useState(false);
  const { selectedTaskId, setSelectedTaskId } = useContext(SelectedTaskContext);

  // √âtat du formulaire
  const [formData, setFormData] = useState({
    date: new Date().toISOString().split("T")[0],
    time: new Date().toLocaleTimeString("fr-FR", {
      hour: "2-digit",
      minute: "2-digit",
    }),
    mood: "",
    consumption: "yes",
  });

  // √âtat pour le tri des entr√©es - Mettre √† jour pour utiliser la valeur du filtre
  const [sortOrder, setSortOrder] = useState("desc");

  // √âtat pour l'heure actuelle
  const [currentTime, setCurrentTime] = useState(new Date());

  // Ajouter cet √©tat pour contr√¥ler l'affichage de la modale
  const [showFilters, setShowFilters] = useState(false);
  
  // Mettre √† jour l'√©tat du filtre pour inclure tous les champs n√©cessaires
  const [filter, setFilter] = useState(() => {
    const savedFilters = localStorage.getItem('consumptionFilters');
    return savedFilters ? JSON.parse(savedFilters) : {
      date: "",
      sortOrder: "desc",
      mood: "",
      consumption: "",
    };
  });

  // Mise √† jour de l'heure chaque seconde
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  // Fonction pour formater l'heure
  const formatClock = (time) => {
    return time.toLocaleTimeString("fr-FR", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
    });
  };

  const handleChange = (key, value) => {
    setFormData({ ...formData, [key]: value });
  };

  const today = new Date().toISOString().split("T")[0];
  const yesterday = new Date(new Date().setDate(new Date().getDate() - 1))
    .toISOString()
    .split("T")[0];
  const dayBeforeYesterday = new Date(new Date().setDate(new Date().getDate() - 2))
    .toISOString()
    .split("T")[0];
  const sevenDaysAgo = new Date(new Date().setDate(new Date().getDate() - 7))
    .toISOString()
    .split("T")[0];
  const startOfMonth = new Date(new Date().getFullYear(), new Date().getMonth(), 1)
    .toISOString()
    .split("T")[0];
  const startOfLastMonth = new Date(new Date().getFullYear(), new Date().getMonth() - 1, 1)
    .toISOString()
    .split("T")[0];
  const endOfLastMonth = new Date(new Date().getFullYear(), new Date().getMonth(), 0)
    .toISOString()
    .split("T")[0];

  const handleAddEntry = () => {
    const moodOptions = {
      heureux: "Heureux üòÄ",
      triste: "Triste üò≠",
      stress√©: "Stress√© üò£",
      calme: "Calme üòå",
      fatigu√©: "Fatigu√© üò¥",
      √©nergique: "√ânergique üòú",
      anxieux: "Anxieux üòñ",
      col√®re: "Col√®re üò°",
      ennuy√©: "Ennuy√© üò©",
      excit√©: "Excit√© ü•≥",
      d√©prim√©: "D√©prim√© üòµ",
      d√©tendu: "D√©tendu üòå",
      nerveux: "Nerveux üòµ‚Äçüí´",
      frustr√©: "Frustr√© üò§",
      d√©termin√©: "D√©termin√© üí™",
      motiv√©: "Motiv√© üöÄ",
      concentr√©: "Concentr√© üßê",
      confiant: "Confiant üòé",
      d√©√ßu: "D√©√ßu üòû",
      d√©go√ªt√©: "D√©go√ªt√© ü§¢",
      honteux: "Honteux üò≥",
      triste: "Triste üò¢",
      d√©motiv√©: "D√©motiv√© üòî",
      fi√©vreux: "Fi√©vreux ü§í",
      malade: "Malade ü§ï",
      ind√©cis: "Ind√©cis ü§î",
      indif√©rent: "Indif√©rent üòê",
    };
    onAddEntry({
      ...formData,
      id: Date.now(),
      createdAt: new Date().toISOString(),
    });
    setFormData({
      date: new Date().toISOString().split("T")[0],
      time: new Date().toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" }),
      mood: "",
      consumption: "yes",
    });
  };

  const handleDeleteEntry = (id) => {
    console.log("ID √† supprimer:", id);
    if (typeof onDeleteEntry === "function") {
      onDeleteEntry(id);
    } else {
      console.error("onDeleteEntry n'est pas d√©fini ou n'est pas une fonction valide.");
    }
  };

  // Calcul de diverses statistiques
  const totalEntries = entries.length;
  const todayEntries = entries.filter(
    (entry) => entry.date.split("T")[0] === today && entry.consumption === "yes"
  ).length;
  const yesterdayEntries = entries.filter(
    (entry) => entry.date.split("T")[0] === yesterday && entry.consumption === "yes"
  ).length;
  const dayBeforeYesterdayEntries = entries.filter(
    (entry) => entry.date.split("T")[0] === dayBeforeYesterday && entry.consumption === "yes"
  ).length;
  const sevenDaysAgoEntries = entries.filter(
    (entry) => entry.date.split("T")[0] === sevenDaysAgo && entry.consumption === "yes"
  ).length;
  const nonConsumptionEntries = entries.filter(
    (entry) => entry.consumption === "no"
  ).length;
  const nonConsumptionTodayEntries = entries.filter(
    (entry) => entry.date.split("T")[0] === today && entry.consumption === "no"
  ).length;
  const thisMonthEntries = entries.filter(
    (entry) => entry.date.split("T")[0] >= startOfMonth && entry.consumption === "yes"
  ).length;
  const lastMonthEntries = entries.filter(
    (entry) =>
      entry.date.split("T")[0] >= startOfLastMonth &&
      entry.date.split("T")[0] <= endOfLastMonth &&
      entry.consumption === "yes"
  ).length;

  // Calcul de la derni√®re entr√©e avec consommation "yes"
  const lastYesEntry = entries
    .filter((entry) => entry.consumption === "yes")
    .reduce((latest, entry) => {
      const entryDate = new Date(entry.createdAt);
      return !latest || entryDate > latest ? entryDate : latest;
    }, null);
  let timeSinceLastYesEntry = null;
  if (lastYesEntry) {
    const diffMs = new Date() - lastYesEntry;
    const hours = Math.floor(diffMs / (1000 * 60 * 60));
    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    timeSinceLastYesEntry = { hours, minutes };
  }

  // Calcul en secondes depuis la derni√®re entr√©e "yes" (pour affichage, pas pour le pourcentage)
const timeSinceLastYesSec = lastYesEntry ? Math.floor((new Date() - lastYesEntry) / 1000) : 0;


// 1. D√©finir le point de d√©part (derni√®re entr√©e "yes" ou d√©but de journ√©e si aucune)
const now = new Date();
let startPoint;

if (lastYesEntry) {
  startPoint = new Date(lastYesEntry);
} else {
  // Si aucune entr√©e "yes", on prend minuit comme d√©part
  startPoint = new Date();
  startPoint.setHours(0, 0, 0, 0);
}

// 2. D√©finir la fin de journ√©e
const endOfDay = new Date();
endOfDay.setHours(23, 59, 59, 999);

// 3. Calcul du temps total depuis le d√©part jusqu'√† la fin du jour
const totalPeriodSec = Math.max(Math.floor((endOfDay - startPoint) / 1000), 1); // On √©vite division par z√©ro

// 4. Calcul du temps √©coul√© depuis le d√©part
const elapsedSec = Math.floor((now - startPoint) / 1000);

// 5. Calcul du pourcentage
const glassProgress = Math.min((elapsedSec / totalPeriodSec) * 100, 100);


  // Fonction pour formater le temps en h, m, s
  const formatTimeDiff = (secs) => {
    const h = Math.floor(secs / 3600);
    const m = Math.floor((secs % 3600) / 60);
    const s = secs % 60;
    return `${h}h ${m}m ${s}s`;
  };

  // Calcul de la derni√®re entr√©e avec consommation "no"
  const lastNoEntry = entries
    .filter((entry) => entry.consumption === "no")
    .reduce((latest, entry) => {
      const entryDate = new Date(entry.createdAt);
      return !latest || entryDate > latest ? entryDate : latest;
    }, null);
  let timeSinceLastNoEntry = null;
  if (lastNoEntry) {
    const diffMs = new Date() - lastNoEntry;
    const hours = Math.floor(diffMs / (1000 * 60 * 60));
    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    timeSinceLastNoEntry = { hours, minutes };
  }

  // Fonction regroupant les statistiques globales (hors dur√©es)
  const getGlobalStats = () => {
    return {
      totalEntries,
      todayEntries,
      yesterdayEntries,
      dayBeforeYesterdayEntries,
      sevenDaysAgoEntries,
      nonConsumptionEntries,
      nonConsumptionTodayEntries,
      thisMonthEntries,
      lastMonthEntries,
    };
  };

  // Mettre √† jour pour utiliser la valeur du filtre pour le tri
  const sortedEntries = [...entries].sort((a, b) => {
    const dateA = new Date(a.createdAt);
    const dateB = new Date(b.createdAt);
    return filter.sortOrder === "asc" ? dateA - dateB : dateB - dateA;
  });

  const globalStats = getGlobalStats();

  const getEmojiAndColor = (count) => {
    if (count <= 3) {
      return { emoji: "üü¢", };
    } else if (count > 3 && count <= 6) {
      return { emoji: "üü†", };
    } else {
      return { emoji: "üî¥", };
    }
  };

  const todayStats = getEmojiAndColor(globalStats.todayEntries);
  const yesterdayStats = getEmojiAndColor(globalStats.yesterdayEntries);
  const dayBeforeYesterdayStats = getEmojiAndColor(globalStats.dayBeforeYesterdayEntries);
  const sevenDaysAgoStats = getEmojiAndColor(globalStats.sevenDaysAgoEntries);

  const getLast15DaysStats = () => {
    const last15Days = [];
    for (let i = 14; i >= 0; i--) {
      const date = new Date(new Date().setDate(new Date().getDate() - i))
        .toISOString()
        .split("T")[0];
      // Compter uniquement les entr√©es dont la date correspond et la consommation est "yes"
      const count = entries.filter(
        (entry) =>
          entry.date.split("T")[0] === date && entry.consumption === "yes"
      ).length;
      // compter uniquement les entr√©es dont la date correspond et la consommation est "no"
      const noCount = entries.filter(
        (entry) =>
          entry.date.split("T")[0] === date && entry.consumption === "no"
      ).length;
      last15Days.push({ date, count, noCount });
    }
    return last15Days;
  };

  const last15DaysStats = getLast15DaysStats();

  const fetchTasks = async () => {
    try {
      const response = await fetch("http://192.168.50.241:4000/tasks");
      if (!response.ok) {
        throw new Error(`HTTP error: ${response.status}`);
      }
      const data = await response.json();
      setTasks(data);
    } catch (error) {
      console.error("Erreur lors du chargement des t√¢ches :", error);
    }
  };

  const getMoodWithEmoji = (mood) => {
    const moodMap = {
      heureux: "Heureux üòÄ",
      triste: "Triste üò≠",
      stress√©: "Stress√© üò£",
      calme: "Calme üòå",
      fatigu√©: "Fatigu√© üò¥",
      √©nergique: "√ânergique üòú",
      anxieux: "Anxieux üòñ",
      col√®re: "Col√®re üò°",
      ennuy√©: "Ennuy√© üò©",
      excit√©: "Excit√© ü•≥",
      d√©prim√©: "D√©prim√© üòµ",
      d√©tendu: "D√©tendu üòå",
      nerveux: "Nerveux üòµ‚Äçüí´",
      frustr√©: "Frustr√© üò§",
      d√©termin√©: "D√©termin√© üí™",
      motiv√©: "Motiv√© üöÄ",
      concentr√©: "Concentr√© üßê",
      confiant: "Confiant üòé",
      d√©√ßu: "D√©√ßu üòû",
      d√©go√ªt√©: "D√©go√ªt√© ü§¢",
      honteux: "Honteux üò≥",
      triste: "Triste üò¢",
      d√©motiv√©: "D√©motiv√© üòî",
      fi√©vreux: "Fi√©vreux ü§í",
      malade: "Malade ü§ï",
      ind√©cis: "Ind√©cis ü§î",
      indif√©rent: "Indif√©rent üòê",
    };
    return moodMap[mood] || mood;
  };

  useEffect(() => {
    fetchTasks();
  }, []);

  const [editEntryModal, setEditEntryModal] = useState(false);
  const [currentEntry, setCurrentEntry] = useState(null);

  // Fonction pour ouvrir la modale d'√©dition pour une entr√©e donn√©e
  const openEditEntryModal = (entry) => {
    setCurrentEntry({ ...entry });
    setEditEntryModal(true);
  };

  // Fonction pour fermer la modale d'√©dition
  const closeEditEntryModal = () => {
    setEditEntryModal(false);
    setCurrentEntry(null);
  };

  // Fonction pour mettre √† jour un champ de l'entr√©e en cours d'√©dition
  const handleEditEntryChange = (field, value) => {
    setCurrentEntry({ ...currentEntry, [field]: value });
  };

  // Fonction pour sauvegarder l'√©dition (ici via une requ√™te PUT)
  const handleSaveEntryEdit = async () => {
    try {
      const response = await fetch(
        `http://192.168.50.241:4000/consumption-entries/${currentEntry._id || currentEntry.id}`,
        {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(currentEntry),
        }
      );
      if (!response.ok) {
        throw new Error("Erreur lors de la mise √† jour de l'entr√©e.");
      }
      // Vous pouvez actualiser la liste des entr√©es ici, par exemple en rappelant une fonction de r√©cup√©ration,
      // ou en mettant √† jour localement l'√©tat.
      closeEditEntryModal();
    } catch (error) {
      console.error("Erreur :", error);
    }
  };

  // Fonction pour supprimer l'entr√©e depuis la modale
  const handleDeleteEntryFromModal = async () => {
    try {
      const response = await fetch(
        `http://192.168.50.241:4000/consumption-entries/${currentEntry._id || currentEntry.id}`,
        { method: "DELETE" }
      );
      if (!response.ok) {
        throw new Error("Erreur lors de la suppression de l'entr√©e.");
      }
      if (typeof onDeleteEntry === "function") {
        onDeleteEntry(currentEntry._id || currentEntry.id);
      }
      closeEditEntryModal();
    } catch (error) {
      console.error("Erreur :", error);
    }
  };

  // Mettre √† jour la logique de tri et de filtrage des entr√©es
  const filteredEntries = sortedEntries.filter(entry => {
    // Filtre par date
    if (filter.date && entry.date.split("T")[0] !== filter.date) {
      return false;
    }
    
    // Filtre par humeur
    if (filter.mood && entry.mood !== filter.mood) {
      return false;
    }
    
    // Filtre par consommation (yes/no)
    if (filter.consumption && entry.consumption !== filter.consumption) {
      return false;
    }
    
    return true;
  });

  // D√©finir les options d'humeur pour le filtre
  const moodOptions = {
    heureux: "Heureux üòÄ",
    triste: "Triste üò≠",
    stress√©: "Stress√© üò£",
    calme: "Calme üòå",
    fatigu√©: "Fatigu√© üò¥",
    √©nergique: "√ânergique üòú",
    anxieux: "Anxieux üòñ",
    col√®re: "Col√®re üò°",
    ennuy√©: "Ennuy√© üò©",
    excit√©: "Excit√© ü•≥",
  };

  // Ajouter cette fonction pour synchroniser le sortOrder avec le filtre
  useEffect(() => {
    setSortOrder(filter.sortOrder || "desc");
  }, [filter.sortOrder]);

  return (

    
    
    <div className="fusion-tool">
      <h1>Fusion-Tool ‚õ©Ô∏è</h1>

      <form className="fusion-form">
        <label>
          Date :
          <input
            type="date"
            value={formData.date}
            onChange={(e) => handleChange("date", e.target.value)}
          />
        </label>
        <label>
          Heure :
          <input
            type="time"
            value={formData.time}
            onChange={(e) => handleChange("time", e.target.value)}
          />
        </label>
        <label>
          Humeur :
          <select
            value={formData.mood}
            onChange={(e) => handleChange("mood", e.target.value)}
          >
            <option value="">S√©lectionnez</option>
            <option value="heureux">Heureux üòÄ</option>
            <option value="triste">Triste üò≠</option>
            <option value="stress√©">Stress√© üò£</option>
            <option value="calme">Calme üòå</option>
            <option value="fatigu√©">Fatigu√© üò¥</option>
            <option value="√©nergique">√ânergique üòú</option>
            <option value="anxieux">Anxieux üòñ</option>
            <option value="col√®re">Col√®re üò°</option>
            <option value="ennuy√©">Ennuy√© üò©</option>
            <option value="excit√©">Excit√© ü•≥</option>
            <option value="d√©prim√©">D√©prim√© üòµ</option>
            <option value="d√©tendu">D√©tendu üòå</option>
            <option value="nerveux">Nerveux üòµ‚Äçüí´</option>
            <option value="frustr√©">Frustr√© üò§</option>
            <option value="d√©termin√©">D√©termin√© üí™</option>
            <option value="motiv√©">Motiv√© üöÄ</option>
            <option value="concentr√©">Concentr√© üßê</option>
            <option value="confiant">Confiant üòé</option>
            <option value="d√©√ßu">D√©√ßu üòû</option>
            <option value="d√©go√ªt√©">D√©go√ªt√© ü§¢</option>
            <option value="honteux">Honteux üò≥</option>
            <option value="triste">Triste üò¢</option>
            <option value="d√©motiv√©">D√©motiv√© üòî</option>
            <option value="fi√©vreux">Fi√©vreux ü§í</option>
            <option value="malade">Malade ü§ï</option>
            <option value="ind√©cis">Ind√©cis ü§î</option>
            <option value="indif√©rent">Indif√©rent üòê</option>
          </select>
        </label>
        <label>
          Consommation :
          <select
            value={formData.consumption}
            onChange={(e) => handleChange("consumption", e.target.value)}
          >
            <option value="yes">Oui</option>
            <option value="no">Non</option>
          </select>
        </label>
        <button type="button" onClick={handleAddEntry}>
          Ajouter
        </button>
      </form>


      <div className="stats-global-FusionTool">


        <StatCard
          label="üì•Last "
          value={lastYesEntry ? `${formatClock(lastYesEntry)}` : "N/A"}
        />

        <StatCard
          label="‚è≥Last "
          value={timeSinceLastYesEntry ? formatTimeDiff(timeSinceLastYesSec) : "N/A"}
          />

<StatCard
          label="üõ°Ô∏èRestant "
          value={`${glassProgress.toFixed(2)}%`}
        />

        <StatCard
          label="‚õ©Ô∏è 0 J "
          value={`${globalStats.todayEntries} ${todayStats.emoji}`}
        />

        <StatCard
          label="‚õ©Ô∏è -1 J "
          value={`${globalStats.yesterdayEntries} ${yesterdayStats.emoji}`}
        />

        <StatCard
          label="‚õ©Ô∏è -2 J "
          value={`${globalStats.dayBeforeYesterdayEntries} ${dayBeforeYesterdayStats.emoji}`}
        />

        <StatCard
          label="‚õ©Ô∏è -7 J "
          value={`${globalStats.sevenDaysAgoEntries} ${sevenDaysAgoStats.emoji}`}
        />

      
        


     

     
     



        <div className="stats-chart-container">
          <BarChartCard
            label="15 derniers jours üóìÔ∏è"
            data={last15DaysStats}
          />
          
        </div>


      </div>

      {/* Ajouter le bouton pour ouvrir la modale des filtres */}
      <button className="show-filters-btn" onClick={() => setShowFilters(true)}>
        Afficher les filtres
      </button>

      {/* Modale des filtres */}
      {showFilters && (
        <div className="modal-overlay">
          <div className="modal-content">
            <button className="close-btn" onClick={() => setShowFilters(false)}>
              Fermer
            </button>
            <ConsumptionFilters
              filter={filter}
              setFilter={setFilter}
              moodOptions={moodOptions}
            />
          </div>
        </div>
      )}

      <h2>Historique des Consommations</h2>
      {/* Supprimer le bouton de tri ici */}

      <table className="fusion-table">
        <thead>
          <tr>
            <th>Date</th>
            <th>Heure</th>
            <th>Humeur</th>
            <th>Consommation</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {filteredEntries.map((entry) => (
            <tr key={entry._id || entry.id}>
              <td>
                {new Date(entry.date).toLocaleDateString("fr-FR", {
                  weekday: "long", // jour de la semaine en lettres
                  day: "2-digit",
                  month: "2-digit",
                  year: "numeric"
                })}
              </td>
              <td>{entry.time}</td>
              <td>{getMoodWithEmoji(entry.mood)}</td>
              <td>{entry.consumption === "yes" ? "Oui" : "Non"}</td>
              <td>
                <button onClick={() => openEditEntryModal(entry)}>
                  √âditer
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Modale d'√©dition d'entr√©e */}
      {editEntryModal && currentEntry && (
        <div className="modal-overlay">
          <div className="modal-content">
            <h3>Modifier l'entr√©e</h3>
            <label>
              Date :
              <input
                type="date"
                value={new Date(currentEntry.date).toISOString().split("T")[0]}
                onChange={(e) => handleEditEntryChange("date", e.target.value)}
              />
            </label>
            <label>
              Heure :
              <input
                type="time"
                value={currentEntry.time}
                onChange={(e) => handleEditEntryChange("time", e.target.value)}
              />
            </label>
            <label>
              Humeur :
              <select
                value={currentEntry.mood}
                onChange={(e) => handleEditEntryChange("mood", e.target.value)}
              >
                <option value="">S√©lectionnez</option>
                <option value="heureux">Heureux üòÄ</option>
                <option value="triste">Triste üò≠</option>
                <option value="stress√©">Stress√© üò£</option>
                <option value="calme">Calme üòå</option>
                <option value="fatigu√©">Fatigu√© üò¥</option>
                <option value="√©nergique">√ânergique üòú</option>
                <option value="anxieux">Anxieux üòñ</option>
                <option value="col√®re">Col√®re üò°</option>
                <option value="ennuy√©">Ennuy√© üò©</option>
                <option value="excit√©">Excit√© ü•≥</option>
                <option value="d√©prim√©">D√©prim√© üòµ</option>
                <option value="d√©tendu">D√©tendu üòå</option>
                <option value="nerveux">Nerveux üòµ‚Äçüí´</option>
                <option value="frustr√©">Frustr√© üò§</option>
                <option value="d√©termin√©">D√©termin√© üí™</option>
                <option value="motiv√©">Motiv√© üöÄ</option>
                <option value="concentr√©">Concentr√© üßê</option>
                <option value="confiant">Confiant üòé</option>
                <option value="d√©√ßu">D√©√ßu üòû</option>
                <option value="d√©go√ªt√©">D√©go√ªt√© ü§¢</option>
                <option value="honteux">Honteux üò≥</option>
                <option value="triste">Triste üò¢</option>
                <option value="d√©motiv√©">D√©motiv√© üòî</option>
                <option value="fi√©vreux">Fi√©vreux ü§í</option>
                <option value="malade">Malade ü§ï</option>
                <option value="ind√©cis">Ind√©cis ü§î</option>
                <option value="indif√©rent">Indif√©rent üòê</option>
              </select>
            </label>
            <label>
              Consommation :
              <select
                value={currentEntry.consumption}
                onChange={(e) =>
                  handleEditEntryChange("consumption", e.target.value)
                }
              >
                <option value="yes">Oui</option>
                <option value="no">Non</option>
              </select>
            </label>
            <div className="modal-buttons">
              <button onClick={handleSaveEntryEdit}>Enregistrer</button>
              <button onClick={closeEditEntryModal}>Annuler</button>
              <button onClick={handleDeleteEntryFromModal}>Supprimer</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default FusionTool;
